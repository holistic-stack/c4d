/**
 * High-level OpenSCAD compiler wrapper around the Rust/WASM pipeline.
 *
 * This module exposes a single entry point `compileSource` that:
 * - Loads the `openscad_wasm` module via `loadWasm`.
 * - Invokes the exported `compile_and_render` function implemented in Rust.
 * - Returns either a successful mesh buffer or a list of structured diagnostics.
 *
 * @example
 * ```ts
 * import { compileSource } from './index';
 *
 * async function compileCubeExample(): Promise<void> {
 *   const result = await compileSource('cube(10);');
 *
 *   if (result.kind === 'success') {
 *     console.log('Vertex buffer length', result.vertices.length);
 *   } else {
 *     console.error('Compilation failed with diagnostics', result.diagnostics);
 *   }
 * }
 * ```
 */

import { loadWasm, type WasmModule } from '../wasm-loader';

/**
 * Source span in bytes, mirroring the Rust `pipeline_types::Span` structure.
 *
 * @example
 * ```ts
 * const span: Span = { start: 0, end: 10 };
 * ```
 */
export interface Span {
  readonly start: number;
  readonly end: number;
}

/**
 * Pipeline stage where a diagnostic originated.
 * This mirrors the Rust `pipeline_types::Stage` enum.
 *
 * @example
 * ```ts
 * const stage: Stage = 'Parse';
 * ```
 */
export type Stage = 'Parse' | 'Ast' | 'Eval' | 'Kernel' | 'Wasm';

/**
 * Structured diagnostic with optional nested causes, used to describe
 * parse/AST/eval/kernel/wasm failures coming from the Rust pipeline.
 *
 * @example
 * ```ts
 * const diagnostic: TraceDiagnostic = {
 *   stage: 'Parse',
 *   message: 'Syntax error',
 *   span: { start: 0, end: 5 },
 *   file: undefined,
 *   hint: 'Check the module call syntax',
 *   causes: undefined
 * };
 * ```
 */
export interface TraceDiagnostic {
  readonly stage: Stage;
  readonly message: string;
  readonly span: Span;
  readonly file?: string;
  readonly hint?: string;
  readonly causes?: TraceDiagnostic[];
}

/**
 * Successful compilation result containing a contiguous vertex buffer.
 * The buffer layout is defined by the Rust kernel (typically xyz triples).
 *
 * @example
 * ```ts
 * if (result.kind === 'success') {
 *   const vertices = result.vertices;
 *   console.log('First vertex x coordinate:', vertices[0]);
 * }
 * ```
 */
export interface CompileSuccess {
  readonly kind: 'success';
  readonly vertices: Float64Array;
}

/**
 * Failed compilation result containing diagnostics.
 *
 * @example
 * ```ts
 * if (result.kind === 'failure') {
 *   for (const diagnostic of result.diagnostics) {
 *     console.error(diagnostic.stage, diagnostic.message);
 *   }
 * }
 * ```
 */
export interface CompileFailure {
  readonly kind: 'failure';
  readonly diagnostics: TraceDiagnostic[];
}

/**
 * Discriminated union describing either a successful mesh or a list
 * of diagnostics when compilation fails.
 */
export type CompileResult = CompileSuccess | CompileFailure;

/**
 * Narrow interface describing the additional `compile_and_render` export
 * that is implemented in the Rust `libs/wasm` crate.
 */
interface WasmModuleWithCompiler extends WasmModule {
  readonly compile_and_render: (source: string) => Float64Array;
}

/**
 * Parse a JSON diagnostics payload into a list of `TraceDiagnostic` values.
 * If parsing fails, a synthetic diagnostic is created instead.
 *
 * @param source - Original OpenSCAD source text used for fallback spans.
 * @param raw - Raw error payload thrown by the WASM export.
 *
 * @example
 * ```ts
 * const diagnostics = parseDiagnostics('cube(10);', '[{"stage":"Parse","message":"err","span":{"start":0,"end":1}}]');
 * ```
 */
function parseDiagnostics(source: string, raw: string): TraceDiagnostic[] {
  try {
    const parsed = JSON.parse(raw) as unknown;

    if (Array.isArray(parsed)) {
      return parsed as TraceDiagnostic[];
    }
  } catch {
    // Fall through to synthetic diagnostic below.
  }

  return [
    {
      stage: 'Wasm',
      message: raw,
      span: { start: 0, end: source.length },
      hint: 'Failed to decode structured diagnostics from WASM error payload.',
      file: undefined,
      causes: undefined
    }
  ];
}

/**
 * Compile OpenSCAD source through the full Rust/WASM pipeline.
 *
 * On success, this function returns a `CompileSuccess` with a `Float64Array`
 * of vertex data. On failure, it returns a `CompileFailure` containing
 * parsed diagnostics, preserving the information generated by the Rust
 * kernel. The function never throws on pipeline errors; instead, it
 * surfaces them as structured diagnostics for the caller to handle.
 *
 * @param source - OpenSCAD source code to compile.
 *
 * @example
 * ```ts
 * const result = await compileSource('cube(10);');
 * if (result.kind === 'success') {
 *   console.log(result.vertices.length);
 * } else {
 *   console.table(result.diagnostics);
 * }
 * ```
 */
export async function compileSource(source: string): Promise<CompileResult> {
  const wasm = (await loadWasm()) as unknown as WasmModuleWithCompiler;

  try {
    const vertices = wasm.compile_and_render(source);
    return {
      kind: 'success',
      vertices
    };
  } catch (error) {
    const message = typeof error === 'string' ? error : String(error);
    const diagnostics = parseDiagnostics(source, message);

    return {
      kind: 'failure',
      diagnostics
    };
  }
}
